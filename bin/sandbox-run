#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
PROFILE_DIR="${SCRIPT_DIR}/../profiles"

# Prevent git from attempting optional lock file writes
export GIT_OPTIONAL_LOCKS=0

# Default credential paths to block (relative to HOME)
# Set SPECTATOR_NO_CRED_BLOCK=1 to disable default credential blocking
DENY_PATHS=()
if [[ "${SPECTATOR_NO_CRED_BLOCK:-}" != "1" ]]; then
  DENY_PATHS=(
    .ssh
    .aws
    .gnupg
    .config/gcloud
    .azure
    .kube
    .docker
    .netrc
    .npmrc
    .git-credentials
    .config/gh
    .local/share/keyrings
  )
fi

# Append user-defined extra deny paths (colon-separated, relative to HOME or absolute)
if [[ -n "${SPECTATOR_EXTRA_DENY:-}" ]]; then
  IFS=':' read -ra EXTRA <<< "$SPECTATOR_EXTRA_DENY"
  DENY_PATHS+=("${EXTRA[@]}")
fi

case "$(uname -s)" in
  Darwin)
    if [[ "${SPECTATOR_NO_CRED_BLOCK:-}" == "1" ]]; then
      PROFILE="${PROFILE_DIR}/readonly-nocred.sb"
    else
      PROFILE="${PROFILE_DIR}/readonly.sb"
    fi

    # If extra deny paths are set, generate a dynamic profile using Python
    # to avoid SBPL injection via unsanitized path interpolation.
    # Rules must be inserted BEFORE (allow file-read*) since SBPL uses first-match.
    if [[ -n "${SPECTATOR_EXTRA_DENY:-}" ]]; then
      TMPPROFILE="$(mktemp)"
      trap 'rm -f "$TMPPROFILE"' EXIT
      PROFILE=$(python3 -c "
import os, sys

profile_path, extra_deny, home = sys.argv[1], sys.argv[2], sys.argv[3]
paths = [p for p in extra_deny.split(':') if p]

# Reject paths containing characters that could break SBPL string literals
for p in paths:
    if '\"' in p or '\\\\' in p:
        print(f'Error: SPECTATOR_EXTRA_DENY path contains unsafe characters: {p}',
              file=sys.stderr)
        sys.exit(1)

# Build SBPL deny rules with safely quoted paths.
# Resolve to real paths so /var -> /private/var etc. match correctly.
rules = []
for p in paths:
    if p.startswith('/'):
        real = os.path.realpath(p)
        rules.append(f'(deny file-read* (subpath \"{real}\"))')
    else:
        real = os.path.realpath(os.path.join(home, p))
        rules.append(f'(deny file-read* (subpath \"{real}\"))')

extra_block = '\n'.join(rules)

with open(profile_path) as f:
    profile = f.read()

# Insert deny rules before the allow-all line
profile = profile.replace('(allow file-read*)', extra_block + '\n(allow file-read*)', 1)

out_path = sys.argv[4]
with open(out_path, 'w') as f:
    f.write(profile)

print(out_path)
" "$PROFILE" "$SPECTATOR_EXTRA_DENY" "$HOME" "$TMPPROFILE")
    fi

    exec sandbox-exec -D "HOME=${HOME}" -f "$PROFILE" "$@"
    ;;
  Linux)
    if ! command -v bwrap &>/dev/null; then
      echo "Error: bwrap (bubblewrap) not installed." >&2
      echo "Install with: sudo apt install bubblewrap" >&2
      exit 1
    fi

    # Build tmpfs mounts for credential paths
    DENY_ARGS=()
    for p in "${DENY_PATHS[@]}"; do
      if [[ "$p" = /* ]]; then
        target="$p"
      else
        target="${HOME}/${p}"
      fi
      # Only mount tmpfs if the path exists (bwrap fails on nonexistent paths)
      if [[ -e "$target" ]]; then
        DENY_ARGS+=(--tmpfs "$target")
      fi
    done

    exec bwrap \
      --ro-bind / / \
      --dev /dev \
      --proc /proc \
      --tmpfs /tmp \
      "${DENY_ARGS[@]}" \
      --unshare-net \
      --unshare-pid \
      --die-with-parent \
      -- "$@"
    ;;
  *)
    echo "Error: Unsupported OS '$(uname -s)'" >&2
    exit 1
    ;;
esac
